-- update

function in_cells(cell,cells)
 local possible = false
  for cell_i in all(cells) do
  if (cell.c == cell_i.c and
   cell.r == cell_i.r) then
   return true
  end
 end
 return false
end

function find_bees()
 local bees = {}
 for row = 2,b-1 do
  for col = 1,b do
   if not (row%2 == 1 and col == b) then
    local stack = board[row][col].b
    if stack != nil then
     for i = 1,#stack do
      local tile = stack[i]
      local t = tile.t
      local s = tile.s
      if s==bee then
       bees[t] = {c=col, r=row}
      end 
     end
    end 
    local t = board[row][col].t
    local s = board[row][col].s
    if s==bee then
     bees[t] = {c=col, r=row}
    end
   end
  end
 end
 return bees
end

function update_possibilities()
 local p
 if cur.s == bee then
  p = nearby_cells(cur.c, cur.r)
  for cell in all(p) do
   if board[cell.r][cell.c].t != 0 then
    del(p, cell)
   end
  end
 elseif cur.s == ant then
  // all
 elseif cur.s == spi then
  // all
 elseif cur.s == btl then
  p = nearby_cells(cur.c, cur.r)
 elseif cur.s == cri then
  // all
 end
  
 possibilities = p
end

function grab_or_place(undo)
 local r = cur.r
 local c = cur.c
 if undo then
  r = cur.from.r
  c = cur.from.c
  cur.r = r
  cur.c = c
  cur.from = nil
 end
 if r < b then
  if cur.t == 0 then
   //grab if cursor empty
   if board[r][c].t == player then
    local stack = board[r][c].b
    if not stack then
     local bees = find_bees()
     if bees[player] == nil then
      message = "cant move until bee is placed"
      return
     end
     cur.from = {c=c, r=r}
     cur.t = board[r][c].t
     cur.s = board[r][c].s
     board[r][c].t = 0
     board[r][c].s = 0
     update_possibilities()
    else
     //if there is a beetle stack
     cur.t = board[r][c].t
     cur.s = board[r][c].s
     cur.from = {c=c, r=r}
     local stacked = stack[#stack]
     board[r][c].t = stacked.t
     board[r][c].s = stacked.s
     update_possibilities()
     del(stack, stacked)
     if #stack == 0 then
      //can't nil stack
      //or it doesnt remove it
      board[r][c].b = nil
     end
    end
   end
  else
   //place if cell empty
   if board[r][c].t == 0 then
    if turns == 0 and
     (r != 8 or c != 8) then
     message = "must place first bug in center"
     return
    else
     if turns == 1 then
      local nearby = nearby_cells(8,8)
      local possible = in_cells(cur,nearby)
      if not possible then
       message = "2nd bug must touch first"
       return
      end
     end
     if rounds > 0 and cur.from != nil and cur.from.r < b then
      if possibilities != nil then
       if not in_cells(cur, possibilities) then
        message = "invalid"
        return
       end
      end
     elseif rounds > 0 and cur.from != nil and cur.from.r == b then
      local nearby = nearby_cells(c,r)
      local stats = nearby_stats(nearby, player)
      if stats.friend < 1 then
       message = "bug must touch same color"
       return
      elseif stats.foe > 0 then
       message = "bug can only touch own color"
       return
      end
     end
     board[r][c].t = cur.t
     board[r][c].s = cur.s
     cur.s = 0
     cur.t = 0
     cur.from = nil
     update_possibilities()
    end
   //place on top if beetle
   elseif cur.s == btl then
    if cur.from != nil and cur.from.r == b then
     message = "can not stack beetle from hand"
     return
    end
    
    if not board[r][c].b then
     board[r][c].b = {}
    end
    local stacked = {t=board[r][c].t,
               s=board[r][c].s}
    add(board[r][c].b, stacked)
    board[r][c].t = cur.t
    board[r][c].s = cur.s
    cur.s = 0
    cur.t = 0
    cur.from = nil
    update_possibilities()
   end
  end
 else
  if cur.t == 0 then
   //grab if cursor empty
   if hands[player][c].t != 0 then
    cur.from = {c=c, r=r}
    cur.t = hands[player][c].t
    cur.s = hands[player][c].s
    hands[player][c].t = 0
    hands[player][c].s = 0
    update_possibilities()
   end
  else
   //place if cell empty
   if hands[player][c].t == 0 then
    hands[player][c].t = cur.t
    hands[player][c].s = cur.s
    cur.s = 0
    cur.t = 0
    cur.from = nil
    update_possibilities()
   end
  end
 end
end

function toggle_player()
 if cur.t == 0 then
  if not can_end_turn() then
   return
  end
  if player == black then
   player = white
  elseif player == white then
   player = black
  end
  turns += 1
  rounds = flr(turns / 2)
  check_win()
 else
  grab_or_place(true)
 end
end

function can_end_turn()
 if turns == 0 then
  if board[8][8].t == 0  then
   message = "must place bug on 1st turn"
   return false
  end
 elseif turns == 1 then
  local nearby = nearby_cells(8,8)
  for cell in all(nearby) do
   if board[cell.r][cell.c].t != 0 then
    return true
   end
  end
  message = "must place bug on 2nd turn"
  return false

 elseif rounds == 4 then
  local hand = hands[player] 
  for i=1,#hand do
   local tile = hand[i]
   if tile.s == bee then
    message = "must place bee by 4th turn"
    return false
   end
  end
 end
 message = ""
 return true
end

function check_win()
 local bees = find_bees()
 for player = 1,2 do
  if bees[player] != nil then
   local col = bees[player].c
   local row = bees[player].r
   local nearby = nearby_cells(col,row)
   local stats = nearby_stats(nearby,player)
   if stats.full == #nearby then
    game_over()
   end
  end
 end 
end

function on_board(col, row)
 local hex = row % 2
 if row < 2 then return false end
 if row > b-1 then return false end
 if col < 1 then return false end
 if col+hex > b then return false end

 return true
end

function nearby_cells(col, row)
 local hex = row % 2 - 1

 local nearby = {}
 if row == b then
  return nearby
 end
 
 //up-left
 add(nearby, {c=col+hex, r=row-1})
 //up-right
 add(nearby, {c=col+hex+1, r=row-1})

 //left
 add(nearby, {c=col-1, r=row})
 //right
 add(nearby, {c=col+1, r=row})
 
 //down-left
 add(nearby, {c=col+hex, r=row+1})
 //down-right
 add(nearby, {c=col+hex+1, r=row+1})

 for cell in all(nearby) do
  if not on_board(cell.c, cell.r) then
   del(nearby, cell)
  end
 end
 
 return nearby
end

function nearby_stats(nearby,team)
 local stats = {empty=0, full=0,
          friend=0, foe=0}
 for cell in all(nearby) do
  local tile = board[cell.r][cell.c]
  if tile.t == 0 then
   stats.empty+=1
  elseif tile.t == team then
   stats.full+=1
   stats.friend+=1
  else
   stats.full+=1
   stats.foe+=1
  end
 end
 
 return stats
end

function _update()
 if state == "start" or
    state == "over" then
  if(btnp(‚ùé)) then
   reset()
  end
  if btnp(üÖæÔ∏è) then
   toggle_manual()
  end
 elseif state == "playing" then
  if btnp(‚¨ÖÔ∏è) or btnp(‚û°Ô∏è) or
   btnp(‚¨ÜÔ∏è) or btnp(‚¨áÔ∏è) then
   message = ""
  end
  if btnp(‚¨ÖÔ∏è) then cur.c-=1 end
  if btnp(‚û°Ô∏è) then cur.c+=1 end
  if btnp(‚¨ÜÔ∏è) then cur.r-=1 end
  if btnp(‚¨áÔ∏è) then cur.r+=1 end
  if cur.c < 1 then cur.c=1 end
  if cur.c > b then cur.c=b end
  if cur.r < 2 then cur.r=2 end
  if cur.r > b then cur.r=b end
  if cur.r%2==1 and cur.c==b then
   cur.c=b-1
  end	  
  if btnp(üÖæÔ∏è) then
   grab_or_place(false)
  end
  if btnp(‚ùé) then
   toggle_player(true)
  end
 elseif state == "manual" then
  if btnp(üÖæÔ∏è) then
   toggle_manual()
  end
  if btnp(‚ùé) then
   manual_page()
  end
 end
end
